"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRollupBuildTarget = addRollupBuildTarget;
const devkit_1 = require("@nx/devkit");
const maybe_js_1 = require("../../../utils/maybe-js");
const versions_1 = require("../../../utils/versions");
async function addRollupBuildTarget(host, options, external = new Set(['react', 'react-dom'])) {
    const tasks = [];
    const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/rollup', versions_1.nxVersion);
    tasks.push(await configurationGenerator(host, {
        ...options,
        project: options.name,
        skipFormat: true,
    }));
    if (!options.skipPackageJson) {
        // These are used in `@nx/react/plugins/bundle-rollup`
        tasks.push((0, devkit_1.addDependenciesToPackageJson)(host, {}, {
            '@rollup/plugin-url': versions_1.rollupPluginUrlVersion,
            '@svgr/rollup': versions_1.svgrRollupVersion,
        }));
    }
    if (options.style === '@emotion/styled') {
        external.add('@emotion/react/jsx-runtime');
    }
    else {
        external.add('react/jsx-runtime');
    }
    const nxJson = (0, devkit_1.readNxJson)(host);
    const hasRollupPlugin = !!nxJson.plugins?.some((p) => typeof p === 'string'
        ? p === '@nx/rollup/plugin'
        : p.plugin === '@nx/rollup/plugin');
    if (hasRollupPlugin) {
        // New behavior, using rollup config file and inferred target.
        host.write((0, devkit_1.joinPathFragments)(options.projectRoot, 'rollup.config.cjs'), `const { withNx } = require('@nx/rollup/with-nx');
const url = require('@rollup/plugin-url');
const svg = require('@svgr/rollup');

module.exports = withNx(
  {
    main: '${(0, maybe_js_1.maybeJs)(options, './src/index.ts')}',
    outputPath: '${options.isUsingTsSolutionConfig
            ? './dist'
            : (0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(options.projectRoot), 'dist', options.projectRoot)}',
    tsConfig: './tsconfig.lib.json',
    compiler: '${options.compiler ?? 'babel'}',
    external: ${JSON.stringify(Array.from(external))},
    format: ${JSON.stringify(options.format ?? ['esm'])},
    assets:[{ input: '.', output: '.', glob: 'README.md'}],
  }, {
    // Provide additional rollup configuration here. See: https://rollupjs.org/configuration-options
    plugins: [
      svg({
        svgo: false,
        titleProp: true,
        ref: true,
      }),
      url({
        limit: 10000, // 10kB
      }),
    ],
  }
);
`);
    }
    else {
        // Legacy behavior, there is a target in project.json using rollup executor.
        const { targets } = (0, devkit_1.readProjectConfiguration)(host, options.name);
        targets.build = {
            executor: '@nx/rollup:rollup',
            outputs: ['{options.outputPath}'],
            options: {
                outputPath: (0, devkit_1.joinPathFragments)('dist', options.projectRoot),
                tsConfig: `${options.projectRoot}/tsconfig.lib.json`,
                project: `${options.projectRoot}/package.json`,
                entryFile: (0, maybe_js_1.maybeJs)(options, `${options.projectRoot}/src/index.ts`),
                external: Array.from(external),
                rollupConfig: `@nx/react/plugins/bundle-rollup`,
                compiler: options.compiler ?? 'babel',
                assets: [
                    {
                        glob: `${options.projectRoot}/README.md`,
                        input: '.',
                        output: '.',
                    },
                ],
            },
        };
        (0, devkit_1.updateProjectConfiguration)(host, options.name, {
            root: options.projectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.projectRoot, 'src'),
            projectType: 'library',
            tags: options.parsedTags,
            targets,
        });
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
